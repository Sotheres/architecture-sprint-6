1) Команда медленно реагирует на проблемы недоступности приложения, узнавая об этом от пользователей. Необходимо внедрить
мониторинг компонентов приложения.
2) core-app обслуживает запросы b2b клиентов, и они конкурируют за ресурсы приложения.
Необходимо обеспечить клиентам равноправный доступ, например, за счет введения rate limiting для запросов.
3) core-app интегрируется с внешними платежными системами, которые ввиду своей недоступности
могут замедлять работу приложения. Необходимо внедрить паттерн retry и circuit breaker для повышения
отказоустойчивости системы. В перспективе рекомендуется разгружать core-app, выделяя его богатый функционал
в отдельные микросервисы. Взаимодействие между core-app и сервисом интеграции с платежными системами
можно реализовать асинхронно для нивелирования влияния технических проблем внешних сервисов на работу приложения.
4) core-app в процессе оформления страховки обращается к сервису client-info для создания/обновления данных о клиенте.
Таким образом процесс оформления страховки завязан на доступность сервиса client-info. Также такая явная связанность
приводит к меньшей гибкости при масштабировании сервиса core-app, приводя к необходимости масштабировать client-info в ответ
на большее число синхронных запросов от возросшего числа реплик core-app.
Для решения данных проблем следует перевести взаимодействие на асинхронную модель. Репликация данных о пользователе
будет осуществляться также через обмен сообщениями между этим двумя сервисами.
5) обращение core-app к сервису ins-product-aggregator раз в 15 минут также формирует явную связанность, и является тяжелым синхронным запросом,
в рамках которого выполняется обращение к 5, а в будущем к 10, внешним API. С перспективой увеличения количества интеграций
и пользовательской нагрузки проблемы задержек и ошибок в работе с внешними API только участятся.
Для того чтобы снизить нагрузку на сеть и не блокировать core-app на долгих запросах, можно асинхронно получать обновленную
информацию о продуктах через соответсвующее сообщение, и таким образом обновлять локальную реплику данных.
6) обращение сервиса ins-comp-settlement к core-app и ins-product-aggregator 1 раз в сутки в конце дня, после пиковой активности, не выглядит
как существенная проблема. В случае увеличения количества и частоты запросов при дальнейшем развитии системы
эти взаимодействия также можно сделать асинхронными.
7) сервисы ins-product-aggregator и ins-comp-settlement обращаются к внешним API страховых компаний. Для этого взаимодействия
также рационально применить подходы retry и circuit breaker.
8) все сервисы используют одну и ту же физическую БД. Выделение отдельной БД под каждый сервис повысит отказоустойчивость системы,
а также позволит масштабировать каждую БД в соответствии с её индивидуальной нагрузкой.
9) в качестве брокера сообщений можно выбрать Apache ActiveMQ Artemis, заложив потенциал для работы с существенно более высокими нагрузками,
чем сегодня. Также ввиду использования Kotlin можно нативно использовать JMS при общении с брокером.
10) после перехода на асинхронное обновление локальных реплик данных следует применить паттерн Transactional Outbox для снижения
вероятности неконсистентности данных в разных сервисах.